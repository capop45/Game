<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Engenheiro Isométrico 2026</title>
    <style>
        :root {
            --primary: #2c3e50;
            --accent: #e67e22;
            --danger: #e74c3c;
            --success: #27ae60;
            --ui-bg: rgba(44, 62, 80, 0.9);
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background: #34495e;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white; user-select: none;
        }

        canvas { display: block; touch-action: none; }

        /* HUD & UI */
        #hud {
            position: absolute; top: 10px; left: 10px; right: 10px;
            display: flex; justify-content: space-between;
            pointer-events: none; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .stat-box { background: var(--ui-bg); padding: 10px; border-radius: 8px; border-left: 4px solid var(--accent); }

        #timer { font-weight: bold; font-size: 1.5rem; transition: color 0.3s; }
        .critical-time { color: var(--danger); animation: blink 0.5s infinite; }

        @keyframes blink { 50% { opacity: 0.3; } }

        /* Rodapé de Controles */
        #controls {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; background: var(--ui-bg);
            padding: 15px; border-radius: 50px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .btn-tool {
            background: #7f8c8d; border: none; padding: 12px 20px;
            color: white; border-radius: 25px; cursor: pointer;
            transition: 0.2s; font-weight: bold;
        }

        .btn-tool.active { background: var(--accent); transform: scale(1.1); }

        /* Overlays */
        .overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.7);
            backdrop-filter: blur(8px); display: none;
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; text-align: center;
        }

        .card { background: var(--primary); padding: 30px; border-radius: 15px; width: 90%; max-width: 400px; }

        input[type="text"] {
            background: #ecf0f1; border: none; padding: 10px;
            font-size: 1.5rem; width: 80px; text-align: center;
            text-transform: uppercase; margin: 15px 0; border-radius: 5px;
        }

        .ranking-table { width: 100%; margin: 20px 0; border-collapse: collapse; }
        .ranking-table td { padding: 5px; border-bottom: 1px solid #555; }

        button.main-btn {
            background: var(--success); color: white; border: none;
            padding: 15px 30px; font-size: 1.2rem; border-radius: 5px;
            cursor: pointer; width: 100%; margin-top: 10px;
        }
    </style>
</head>
<body>

    <div id="hud">
        <div class="stat-box">
            Altura: <span id="txt-alt">0</span> / <span id="target-alt">0</span>m<br>
            Custo: R$ <span id="txt-budget">0</span>
        </div>
        <div class="stat-box" id="timer">60:00</div>
    </div>

    <div id="controls">
        <button class="btn-tool active" onclick="setTool('pilar')">PILAR (Concrete)</button>
        <button class="btn-tool" onclick="setTool('viga')">VIGA (Concrete)</button>
        <button class="btn-tool" onclick="setTool('parede')">PAREDE (Alv.)</button>
    </div>

    <div id="screen-start" class="overlay" style="display: flex;">
        <div class="card">
            <h2>CIVIL MASTER 2.5D</h2>
            <p>Selecione a Dificuldade:</p>
            <button class="main-btn" onclick="startGame('easy')" style="background:#27ae60">FÁCIL (Alvo 10m)</button>
            <button class="main-btn" onclick="startGame('medium')" style="background:#e67e22">MÉDIO (Alvo 20m)</button>
            <button class="main-btn" onclick="startGame('hard')" style="background:#c0392b">DIFÍCIL (Alvo 40m)</button>
        </div>
    </div>

    <div id="screen-gameover" class="overlay">
        <div class="card">
            <h1 id="end-title">FIM DE JOGO</h1>
            <p id="end-msg"></p>
            <div id="win-section" style="display:none">
                <h3>Sua Pontuação: <span id="final-score">0</span></h3>
                <input type="text" id="player-name" maxlength="3" placeholder="AAA">
                <button class="main-btn" onclick="saveScore()">Salvar Ranking</button>
            </div>
            <div id="ranking-container"></div>
            <button class="main-btn" onclick="location.reload()" style="background:#7f8c8d">Reiniciar</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        /**
         * CONFIGURAÇÕES E ESTADOS
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = 'start';
        let config = { budget: 0, target: 0, mult: 1 };
        let timeLeft = 3600; // 60 minutos
        let blocks = [];
        let currentTool = 'pilar';
        let gridSize = 40;
        let isoAngle = Math.PI / 6;

        const MATERIALS = {
            pilar:  { w: 0.4, h: 3, d: 0.4, cost: 500, density: 2400, limit: 25000000, color: '#95a5a6' },
            viga:   { w: 2, h: 0.4, d: 0.4, cost: 300, density: 2400, limit: 15000000, color: '#7f8c8d' },
            parede: { w: 2, h: 3, d: 0.2, cost: 200, density: 1600, limit: 5000000, color: '#d35400' }
        };

        /**
         * INICIALIZAÇÃO
         */
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        function startGame(difficulty) {
            document.getElementById('screen-start').style.display = 'none';
            gameState = 'playing';
            
            if(difficulty === 'easy') config = { budget: 50000, target: 10, mult: 1 };
            if(difficulty === 'medium') config = { budget: 30000, target: 20, mult: 2 };
            if(difficulty === 'hard') config = { budget: 15000, target: 40, mult: 3 };

            document.getElementById('target-alt').innerText = config.target;
            updateHUD();
            startTimer();
            loop();
        }

        /**
         * MOTOR DE FÍSICA E CÁLCULOS
         */
        function calculateStructuralPhysics() {
            // Reseta tensões
            blocks.forEach(b => b.tension = 0);

            // Propagação de carga de cima para baixo
            // Para simplificação em tempo real: ordenamos por Z (altura) descendente
            let sorted = [...blocks].sort((a,b) => b.z - a.z);

            sorted.forEach(topBlock => {
                let weight = topBlock.vol * MATERIALS[topBlock.type].density * 9.8;
                topBlock.tension += weight;

                // Transfere peso para quem está abaixo (contato simples)
                blocks.forEach(botBlock => {
                    if (topBlock === botBlock) return;
                    // Checa colisão AABB simples no plano XY e se está logo abaixo
                    if (Math.abs(topBlock.x - botBlock.x) < (topBlock.w + botBlock.w)/2 &&
                        Math.abs(topBlock.y - botBlock.y) < (topBlock.d + botBlock.d)/2 &&
                        Math.abs(topBlock.z - (botBlock.z + botBlock.h)) < 0.1) {
                        botBlock.tension += topBlock.tension;
                    }
                });
            });

            // Verifica colapso
            for (let b of blocks) {
                let area = b.w * b.d;
                let pressure = b.tension / area;
                b.stressRatio = pressure / MATERIALS[b.type].limit;

                if (b.stressRatio > 1.0) return endGame('A estrutura colapsou devido ao excesso de carga!');
            }
        }

        /**
         * RENDERIZAÇÃO ISOMÉTRICA
         */
        function toScreen(x, y, z) {
            // O segredo da projeção 2.5D:
            const scX = (x - y) * Math.cos(isoAngle);
            const scY = (x + y) * Math.sin(isoAngle) - z;
            return {
                x: canvas.width / 2 + scX * gridSize,
                y: canvas.height * 0.8 + scY * gridSize
            };
        }

        function drawBlock(b) {
            const mat = MATERIALS[b.type];
            // Cor baseada no stress (Verde -> Vermelho)
            const r = Math.floor(255 * b.stressRatio);
            const g = Math.floor(255 * (1 - b.stressRatio));
            const color = `rgb(${r},${g},50)`;

            const points = [
                toScreen(b.x - b.w/2, b.y - b.d/2, b.z),
                toScreen(b.x + b.w/2, b.y - b.d/2, b.z),
                toScreen(b.x + b.w/2, b.y + b.d/2, b.z),
                toScreen(b.x - b.w/2, b.y + b.d/2, b.z),
                toScreen(b.x - b.w/2, b.y - b.d/2, b.z + b.h),
                toScreen(b.x + b.w/2, b.y - b.d/2, b.z + b.h),
                toScreen(b.x + b.w/2, b.y + b.d/2, b.z + b.h),
                toScreen(b.x - b.w/2, b.y + b.d/2, b.z + b.h)
            ];

            const drawFace = (pIdx, fColor) => {
                ctx.beginPath();
                ctx.fillStyle = fColor;
                ctx.moveTo(points[pIdx[0]].x, points[pIdx[0]].y);
                pIdx.forEach(i => ctx.lineTo(points[i].x, points[i].y));
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            };

            ctx.strokeStyle = "rgba(0,0,0,0.2)";
            drawFace([0,1,5,4], color); // Leste
            drawFace([1,2,6,5], color); // Sul
            drawFace([4,5,6,7], color); // Topo
        }

        /**
         * LÓGICA DE JOGO
         */
        function loop() {
            if (gameState !== 'playing') return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Desenha Chão/Grid
            ctx.beginPath();
            ctx.strokeStyle = "#444";
            for(let i=-5; i<=5; i++) {
                let p1 = toScreen(i, -5, 0); let p2 = toScreen(i, 5, 0);
                ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                p1 = toScreen(-5, i, 0); p2 = toScreen(5, i, 0);
                ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
            }
            ctx.stroke();

            // Ordena blocos para o "Painter's Algorithm" (quem tá atrás/baixo desenha primeiro)
            blocks.sort((a,b) => (a.z - b.z) || (a.x + a.y) - (b.x + b.y));
            blocks.forEach(drawBlock);

            calculateStructuralPhysics();
            checkWinCondition();

            requestAnimationFrame(loop);
        }

        function checkWinCondition() {
            let maxH = blocks.reduce((max, b) => Math.max(max, b.z + b.h), 0);
            document.getElementById('txt-alt').innerText = maxH.toFixed(1);
            
            if (maxH >= config.target) {
                endGame('Objetivo de altura alcançado!', true);
            }
        }

        function startTimer() {
            const timerEl = document.getElementById('timer');
            const interval = setInterval(() => {
                if (gameState !== 'playing') { clearInterval(interval); return; }
                
                timeLeft--;
                let min = Math.floor(timeLeft / 60);
                let sec = timeLeft % 60;
                timerEl.innerText = `${min.toString().padStart(2,'0')}:${sec.toString().padStart(2,'0')}`;

                if (timeLeft <= 60) timerEl.classList.add('critical-time');
                if (timeLeft <= 0) endGame('O tempo acabou!');
            }, 1000);
        }

        /**
         * INPUT E CONSTRUÇÃO
         */
        canvas.addEventListener('mousedown', (e) => {
            if (gameState !== 'playing') return;

            // Simplificação de Raycasting para Grid Isométrico:
            // Convertemos o clique de volta para coordenadas de mundo aproximadas
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left - canvas.width/2;
            const mouseY = e.clientY - rect.top - canvas.height*0.8;

            // Inversa da projeção (Z considerado 0 para o clique inicial ou baseado no topo)
            let currZ = findTopAt(0, 0); // Simplificado para centro
            
            // Para este protótipo, vamos permitir construir empilhado no centro ou adjacente
            const mat = MATERIALS[currentTool];
            
            if (config.budget < mat.cost) return;

            // Lógica de posicionamento (empilhamento automático)
            let spawnZ = 0;
            blocks.forEach(b => {
                if (b.z + b.h > spawnZ) spawnZ = b.z + b.h;
            });

            const newBlock = {
                type: currentTool,
                x: 0, y: 0, z: spawnZ,
                w: mat.w, h: mat.h, d: mat.d,
                vol: mat.w * mat.h * mat.d,
                stressRatio: 0, tension: 0
            };

            blocks.push(newBlock);
            config.budget -= mat.cost;
            updateHUD();

            if (config.budget < 0) endGame('Seu orçamento estourou!');
        });

        function findTopAt(x, y) {
            let top = 0;
            blocks.forEach(b => { if(b.z + b.h > top) top = b.z + b.h; });
            return top;
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.btn-tool').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
        }

        function updateHUD() {
            document.getElementById('txt-budget').innerText = config.budget;
        }

        /**
         * RANKING E FINALIZAÇÃO
         */
        function endGame(msg, win = false) {
            gameState = 'end';
            document.getElementById('screen-gameover').style.display = 'flex';
            document.getElementById('end-title').innerText = win ? "MISSÃO CUMPRIDA!" : "FALHA ESTRUTURAL";
            document.getElementById('end-title').style.color = win ? "var(--success)" : "var(--danger)";
            document.getElementById('end-msg').innerText = msg;

            if (win) {
                /** * FÓRMULA DE PONTUAÇÃO:
                 * (Grana que sobrou + (tempo restante * 10)) * Dificuldade
                 */
                let score = Math.floor((config.budget + (timeLeft * 10)) * config.mult);
                document.getElementById('final-score').innerText = score;
                document.getElementById('win-section').style.display = 'block';
            }
            showRanking();
        }

        function saveScore() {
            const name = document.getElementById('player-name').value.toUpperCase() || 'ANON';
            const score = parseInt(document.getElementById('final-score').innerText);
            let ranking = JSON.parse(localStorage.getItem('isometric_rank') || '[]');
            
            ranking.push({ name, score });
            ranking.sort((a, b) => b.score - a.score);
            ranking = ranking.slice(0, 5);
            
            localStorage.setItem('isometric_rank', JSON.stringify(ranking));
            document.getElementById('win-section').style.display = 'none';
            showRanking();
        }

        function showRanking() {
            let ranking = JSON.parse(localStorage.getItem('isometric_rank') || '[]');
            let html = '<table class="ranking-table"><tr><th>POS</th><th>ENG</th><th>PTS</th></tr>';
            ranking.forEach((r, i) => {
                html += `<tr><td>${i+1}º</td><td>${r.name}</td><td>${r.score}</td></tr>`;
            });
            html += '</table>';
            document.getElementById('ranking-container').innerHTML = html;
        }

    </script>
</body>
</html>
