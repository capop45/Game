<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Engenharia Estática - Arranha-Céu</title>
    <style>
        :root {
            --ui-bg: rgba(20, 25, 30, 0.95);
            --primary: #3498db;
            --wood: #8B5A2B;
            --concrete: #7f8c8d;
            --steel: #2c3e50;
        }
        
        * { box-sizing: border-box; user-select: none; }
        
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: #87CEEB; /* Céu */
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Previne scroll no mobile */
        }
        
        canvas { display: block; width: 100%; height: 100%; }

        #hud {
            position: absolute; top: 0; left: 0; width: 100%;
            padding: 15px; text-align: center; pointer-events: none;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
            color: white; font-size: 24px; font-weight: bold;
        }

        #game-over {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: white; padding: 30px; border-radius: 10px;
            text-align: center; display: none; z-index: 100;
        }

        #game-over button {
            margin-top: 15px; padding: 10px 20px; font-size: 18px; cursor: pointer;
            background: var(--primary); color: white; border: none; border-radius: 5px;
        }

        /* Rodapé de Controles */
        #controls {
            position: absolute; bottom: 0; left: 0; width: 100%;
            background: var(--ui-bg); padding: 15px 10px;
            display: flex; flex-direction: column; gap: 10px;
            border-top: 2px solid rgba(255,255,255,0.1);
        }

        .control-row { display: flex; justify-content: space-around; gap: 10px; }

        .btn {
            flex: 1; padding: 15px 5px; font-size: 16px; font-weight: bold;
            border: 2px solid transparent; border-radius: 8px; cursor: pointer;
            color: white; text-align: center; transition: 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .btn:active { transform: translateY(2px); box-shadow: 0 1px 2px rgba(0,0,0,0.3); }
        .btn.active { border-color: white; outline: 2px solid var(--primary); }

        /* Cores dos Materiais */
        #btn-wood { background-color: var(--wood); }
        #btn-concrete { background-color: var(--concrete); }
        #btn-steel { background-color: var(--steel); }
        
        /* Orientação */
        #btn-pilar, #btn-viga { background-color: #444; }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="hud">Altura: <span id="score">0</span>m</div>

    <div id="game-over">
        <h2>FALHA ESTRUTURAL</h2>
        <p>A estrutura colapsou.</p>
        <p>Altura Máxima: <span id="final-score">0</span>m</p>
        <button onclick="resetGame()">Reiniciar Projeto</button>
    </div>

    <div id="controls">
        <div class="control-row">
            <button class="btn active" id="btn-wood" onclick="selectMaterial('wood')">Madeira</button>
            <button class="btn" id="btn-concrete" onclick="selectMaterial('concrete')">Concreto</button>
            <button class="btn" id="btn-steel" onclick="selectMaterial('steel')">Aço</button>
        </div>
        <div class="control-row">
            <button class="btn active" id="btn-pilar" onclick="selectOrientation('pilar')">Pilar (V)</button>
            <button class="btn" id="btn-viga" onclick="selectOrientation('viga')">Viga (H)</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Configuração de Tela e Câmera
        let width, height, groundY;
        let cameraY = 0;
        let targetCameraY = 0;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            groundY = height - document.getElementById('controls').offsetHeight - 50;
        }
        window.addEventListener('resize', resize);

        // --- SISTEMA DE MATERIAIS ---
        // Densidade: afeta o peso gerado.
        // Resistência: tensão máxima (Força/Área) suportada antes da ruptura.
        const MATERIALS = {
            wood:     { id: 'wood', color: '#8B5A2B', density: 0.5, strength: 300 },
            concrete: { id: 'concrete', color: '#7f8c8d', density: 2.5, strength: 1200 },
            steel:    { id: 'steel', color: '#2c3e50', density: 7.8, strength: 6000 }
        };

        const DIMENSIONS = {
            pilar: { w: 20, h: 100 }, // Vertical
            viga:  { w: 120, h: 20 }  // Horizontal
        };

        // Estado do Jogo
        let blocks = [];
        let particles = [];
        let currentMaterial = 'wood';
        let currentOrientation = 'pilar';
        let gameState = 'playing'; // playing, gameover
        let score = 0;
        let maxScore = 0;

        // Controle de Input/Preview
        let touchX = -1;
        let touchY = -1;
        let isTouching = false;

        // Inicialização
        function resetGame() {
            blocks = [];
            particles = [];
            cameraY = 0;
            targetCameraY = 0;
            score = 0;
            maxScore = 0;
            gameState = 'playing';
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('score').innerText = '0';
        }

        // Funções de UI
        function selectMaterial(mat) {
            currentMaterial = mat;
            document.querySelectorAll('.control-row:first-child .btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-' + mat).classList.add('active');
        }

        function selectOrientation(ori) {
            currentOrientation = ori;
            document.querySelectorAll('.control-row:last-child .btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-' + ori).classList.add('active');
        }

        // Eventos Touch/Mouse
        function handleStart(e) {
            if (gameState !== 'playing') return;
            let clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            // Ignorar toques na área de controles
            if (clientY > height - document.getElementById('controls').offsetHeight) return;

            isTouching = true;
            touchX = clientX;
            touchY = clientY;
        }

        function handleMove(e) {
            if (!isTouching) return;
            touchX = e.touches ? e.touches[0].clientX : e.clientX;
            touchY = e.touches ? e.touches[0].clientY : e.clientY;
        }

        function handleEnd(e) {
            if (!isTouching || gameState !== 'playing') return;
            isTouching = false;
            spawnBlock(touchX);
        }

        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('touchmove', handleMove);
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);

        // Criar Novo Bloco
        function spawnBlock(x) {
            let dim = DIMENSIONS[currentOrientation];
            let mat = MATERIALS[currentMaterial];
            
            // Alinhar a grade (grid) invisível para facilitar construção
            let snapX = Math.round((x - dim.w / 2) / 10) * 10;
            
            blocks.push({
                x: snapX,
                y: -cameraY - dim.h, // Spawna no topo da tela visível
                w: dim.w,
                h: dim.h,
                material: mat,
                falling: true,
                supportedLoad: 0,
                stress: 0,
                broken: false
            });
        }

        // --- CÁLCULOS E MOTOR DE FÍSICA ---
        function updatePhysics() {
            let anyFalling = false;

            // Gravidade e Colisão
            blocks.forEach(b => {
                if (b.falling && !b.broken) {
                    anyFalling = true;
                    b.y += 8; // Velocidade de queda constante para simplificar

                    // Checar colisão com o chão
                    if (b.y + b.h >= groundY) {
                        b.y = groundY - b.h;
                        b.falling = false;
                    } else {
                        // Checar colisão com outros blocos
                        for (let other of blocks) {
                            if (other !== b && !other.falling && !other.broken) {
                                // AABB simples com tolerância de queda
                                if (b.x < other.x + other.w && b.x + b.w > other.x &&
                                    b.y + b.h >= other.y && b.y + b.h <= other.y + 10) {
                                    b.y = other.y - b.h; // Senta exatamente em cima
                                    b.falling = false;
                                    break;
                                }
                            }
                        }
                    }
                }
            });

            // Se nada estiver caindo, processar a distribuição de carga
            if (!anyFalling && gameState === 'playing' && blocks.length > 0) {
                calculateStaticLoads();
            }

            // Atualizar Câmera e Placar
            let highestY = groundY;
            blocks.forEach(b => { if (!b.falling && b.y < highestY) highestY = b.y; });
            
            score = Math.floor((groundY - highestY) / 10);
            if (score > maxScore) {
                maxScore = score;
                document.getElementById('score').innerText = maxScore;
            }

            // Mover a câmera suavemente se a torre subir acima de 60% da tela
            let desiredTop = height * 0.4;
            let currentTopOffset = highestY + cameraY;
            if (currentTopOffset < desiredTop) {
                targetCameraY += (desiredTop - currentTopOffset);
            }
            cameraY += (targetCameraY - cameraY) * 0.1;
        }

        /* * LÓGICA DE ENGENHARIA ESTRUTURAL (Propagação de Carga Descendente)
         * Fórmula adotada para distribuição de peso:
         * 1. Peso Próprio (P) = Densidade * Largura * Altura.
         * 2. Carga Total no Bloco (Q) = P + Soma das cargas transferidas pelos blocos acima.
         * 3. Tensão no Bloco (Sigma) = Q / Largura de Contato Total (Área em 2D).
         * 4. Distribuição: A Carga Total (Q) de um bloco é transferida aos suportes abaixo
         * proporcionalmente à área (largura) de contato de cada suporte.
         */
        function calculateStaticLoads() {
            // Resetar estados
            blocks.forEach(b => {
                b.supportedLoad = 0;
                b.stress = 0;
            });

            // Ordenar de cima para baixo (menor Y para maior Y) para cascata correta
            let sorted = [...blocks].filter(b => !b.broken).sort((a, b) => a.y - b.y);

            let hasCollapse = false;

            for (let i = 0; i < sorted.length; i++) {
                let block = sorted[i];
                
                // 1. Peso do Bloco
                let weight = block.material.density * block.w * block.h;
                // 2. Carga Total = Peso próprio + Carga recebida de cima
                let totalLoad = weight + block.supportedLoad;

                // 3. Calcular Tensão atual
                block.stress = totalLoad / block.w;

                // Checar Ruptura: Se tensão > Limite de Escoamento (Strength)
                if (block.stress > block.material.strength) {
                    triggerCollapse(block);
                    hasCollapse = true;
                    continue; // Bloco quebrou, não transmite mais carga perfeitamente
                }

                // 4. Propagação de Carga: Encontrar suportes abaixo
                let supports = [];
                let totalContactWidth = 0;

                for (let j = i + 1; j < sorted.length; j++) {
                    let below = sorted[j];
                    // Tolerância mínima para considerar contato vertical (Y)
                    if (Math.abs(below.y - (block.y + block.h)) < 2) {
                        // Calcular intersecção horizontal (X)
                        let overlapLeft = Math.max(block.x, below.x);
                        let overlapRight = Math.min(block.x + block.w, below.x + below.w);
                        let contact = overlapRight - overlapLeft;

                        if (contact > 0) {
                            supports.push({ target: below, width: contact });
                            totalContactWidth += contact;
                        }
                    }
                }

                // Distribuir a carga proporcionalmente ao contato
                if (supports.length > 0) {
                    supports.forEach(sup => {
                        let fraction = sup.width / totalContactWidth;
                        sup.target.supportedLoad += totalLoad * fraction;
                    });
                } else if (block.y + block.h < groundY - 2) {
                    // Está flutuando sem suporte e não está no chão? Volta a cair.
                    block.falling = true;
                }
            }

            if (hasCollapse) {
                // Game Over - Reação em cadeia
                gameState = 'gameover';
                document.getElementById('final-score').innerText = maxScore;
                document.getElementById('game-over').style.display = 'block';
                
                // Desestabiliza blocos não quebrados (Efeito físico de desabamento visual)
                blocks.forEach(b => {
                    if (!b.broken) b.falling = true;
                });
            }
        }

        function triggerCollapse(block) {
            block.broken = true;
            // Gerar partículas
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: block.x + Math.random() * block.w,
                    y: block.y + Math.random() * block.h,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 1) * 10,
                    size: Math.random() * 5 + 2,
                    color: block.material.color,
                    life: 1.0
                });
            }
        }

        // --- RENDERIZAÇÃO ---
        function draw() {
            ctx.clearRect(0, 0, width, height);

            // Desenhar Chão
            ctx.fillStyle = '#27ae60';
            ctx.fillRect(0, groundY + cameraY, width, height - groundY);

            // Chão profundo (Terra)
            ctx.fillStyle = '#8e44ad';
            ctx.fillRect(0, groundY + cameraY + 20, width, height);

            // Preview Ghost
            if (isTouching && gameState === 'playing') {
                let dim = DIMENSIONS[currentOrientation];
                let snapX = Math.round((touchX - dim.w / 2) / 10) * 10;
                
                ctx.fillStyle = MATERIALS[currentMaterial].color;
                ctx.globalAlpha = 0.4;
                ctx.fillRect(snapX, -dim.h + 20 + cameraY, dim.w, dim.h);
                
                // Linha de guia
                ctx.beginPath();
                ctx.moveTo(snapX + dim.w/2, cameraY);
                ctx.lineTo(snapX + dim.w/2, height);
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.globalAlpha = 1.0;
            }

            // Desenhar Blocos
            blocks.forEach(b => {
                if (b.broken) return;

                // Cor base do material
                ctx.fillStyle = b.material.color;
                ctx.fillRect(b.x, b.y + cameraY, b.w, b.h);

                // Contorno
                ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                ctx.lineWidth = 1;
                ctx.strokeRect(b.x, b.y + cameraY, b.w, b.h);

                // Feedback Visual de Tensão (Stress/Strain)
                if (!b.falling && b.stress > 0) {
                    let stressRatio = Math.min(b.stress / b.material.strength, 1);
                    // Gradiente para vermelho indica aproximação do limite de escoamento
                    if (stressRatio > 0.1) {
                        ctx.fillStyle = `rgba(255, 0, 0, ${stressRatio * 0.8})`;
                        ctx.fillRect(b.x, b.y + cameraY, b.w, b.h);
                    }
                }
            });

            // Partículas
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.5; // Gravidade
                p.life -= 0.02;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                } else {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y + cameraY, p.size, p.size);
                    ctx.globalAlpha = 1.0;
                }
            }
        }

        // Loop Principal
        function gameLoop() {
            updatePhysics();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Boot
        resize();
        gameLoop();

    </script>
</body>
</html>
