<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Engenheiro 3D 2026</title>
    <style>
        :root {
            --primary: #2c3e50;
            --accent: #e67e22;
            --danger: #e74c3c;
            --success: #27ae60;
            --ui-bg: rgba(44, 62, 80, 0.9);
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background: #34495e;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white; user-select: none;
        }

        /* Impede comportamentos indesejados no mobile como pinch-to-zoom nativo */
        canvas { 
            display: block; 
            touch-action: none; 
            outline: none;
        }

        /* HUD & UI */
        #hud {
            position: absolute; top: 10px; left: 10px; right: 10px;
            display: flex; justify-content: space-between;
            pointer-events: none; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
        }

        .stat-box { 
            background: var(--ui-bg); padding: 10px; 
            border-radius: 8px; border-left: 4px solid var(--accent); 
        }

        #timer { font-weight: bold; font-size: 1.5rem; transition: color 0.3s; }
        .critical-time { color: var(--danger); animation: blink 0.5s infinite; }

        @keyframes blink { 50% { opacity: 0.3; } }

        /* Rodapé de Controles */
        #controls {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; background: var(--ui-bg);
            padding: 15px; border-radius: 50px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 10;
        }

        .btn-tool {
            background: #7f8c8d; border: none; padding: 12px 20px;
            color: white; border-radius: 25px; cursor: pointer;
            transition: 0.2s; font-weight: bold; pointer-events: auto;
        }

        .btn-tool.active { background: var(--accent); transform: scale(1.1); }

        /* Overlays */
        .overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.7);
            backdrop-filter: blur(8px); display: none;
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; text-align: center;
        }

        .card { background: var(--primary); padding: 30px; border-radius: 15px; width: 90%; max-width: 400px; }

        input[type="text"] {
            background: #ecf0f1; border: none; padding: 10px;
            font-size: 1.5rem; width: 80px; text-align: center;
            text-transform: uppercase; margin: 15px 0; border-radius: 5px;
        }

        .ranking-table { width: 100%; margin: 20px 0; border-collapse: collapse; }
        .ranking-table td { padding: 5px; border-bottom: 1px solid #555; }

        button.main-btn {
            background: var(--success); color: white; border: none;
            padding: 15px 30px; font-size: 1.2rem; border-radius: 5px;
            cursor: pointer; width: 100%; margin-top: 10px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="hud">
        <div class="stat-box">
            Altura: <span id="txt-alt">0</span> / <span id="target-alt">0</span>m<br>
            Base Mínima: <span id="txt-area">0</span> / <span id="target-area">0</span>m²<br>
            Custo: R$ <span id="txt-budget">0</span>
        </div>
        <div class="stat-box" id="timer">60:00</div>
    </div>

    <div id="controls">
        <button class="btn-tool active" onclick="setTool('pilar')">PILAR</button>
        <button class="btn-tool" onclick="setTool('viga')">VIGA</button>
        <button class="btn-tool" onclick="setTool('parede')">PAREDE</button>
    </div>

    <div id="screen-start" class="overlay" style="display: flex;">
        <div class="card">
            <h2>CIVIL MASTER 3D</h2>
            <p>Selecione a Dificuldade:</p>
            <button class="main-btn" onclick="startGame('easy')" style="background:#27ae60">FÁCIL (10m Altura / 4m² Base)</button>
            <button class="main-btn" onclick="startGame('medium')" style="background:#e67e22">MÉDIO (20m Altura / 10m² Base)</button>
            <button class="main-btn" onclick="startGame('hard')" style="background:#c0392b">DIFÍCIL (40m Altura / 20m² Base)</button>
        </div>
    </div>

    <div id="screen-gameover" class="overlay">
        <div class="card">
            <h1 id="end-title">FIM DE JOGO</h1>
            <p id="end-msg"></p>
            <div id="win-section" style="display:none">
                <h3>Sua Pontuação: <span id="final-score">0</span></h3>
                <input type="text" id="player-name" maxlength="3" placeholder="AAA">
                <button class="main-btn" onclick="saveScore()">Salvar Ranking</button>
            </div>
            <div id="ranking-container"></div>
            <button class="main-btn" onclick="location.reload()" style="background:#7f8c8d">Reiniciar</button>
        </div>
    </div>

    <script>
        /**
         * ==========================================
         * 1. CONFIGURAÇÕES GERAIS E ESTADO DO JOGO
         * ==========================================
         */
        let gameState = 'start';
        let config = { budget: 0, targetAlt: 0, targetArea: 0, mult: 1 };
        let timeLeft = 3600;
        let blocks = [];
        let currentTool = 'pilar';

        const MATERIALS = {
            pilar:  { w: 0.4, h: 3, d: 0.4, cost: 500, density: 2400, limit: 25000000, color: 0x95a5a6 },
            viga:   { w: 2.0, h: 0.4, d: 0.4, cost: 300, density: 2400, limit: 15000000, color: 0x7f8c8d },
            parede: { w: 2.0, h: 3.0, d: 0.2, cost: 200, density: 1600, limit: 5000000,  color: 0xd35400 }
        };

        const GRID_SNAP = 0.2; // Precisão de alinhamento ao construir

        /**
         * ==========================================
         * 2. SETUP DO THREE.JS (CENA, CÂMERA, LUZES)
         * ==========================================
         */
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x34495e);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Controles de Câmera (Mobile Touch-Friendly)
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.05; // Impede a câmera de ir para baixo da terra

        // Luzes
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(20, 40, 20);
        dirLight.castShadow = true;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -20;
        scene.add(dirLight);

        // Chão e Grid
        const gridHelper = new THREE.GridHelper(40, 40, 0x000000, 0x000000);
        gridHelper.material.opacity = 0.2;
        gridHelper.material.transparent = true;
        scene.add(gridHelper);

        const groundGeo = new THREE.PlaneGeometry(40, 40);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50, depthWrite: false });
        const groundPlane = new THREE.Mesh(groundGeo, groundMat);
        groundPlane.rotation.x = -Math.PI / 2;
        groundPlane.receiveShadow = true;
        scene.add(groundPlane);

        // Ajuste de Tela (Responsividade)
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        /**
         * ==========================================
         * 3. LÓGICA DE RAYCASTING E CONSTRUÇÃO
         * ==========================================
         */
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Variável para evitar construir enquanto o usuário arrasta a tela (OrbitControls)
        let isDragging = false;
        let pointerDownPos = { x: 0, y: 0 };

        window.addEventListener('pointerdown', (e) => {
            if (gameState !== 'playing' || e.target.tagName !== 'CANVAS') return;
            pointerDownPos = { x: e.clientX, y: e.clientY };
            isDragging = false;
        });

        window.addEventListener('pointermove', (e) => {
            if (Math.abs(e.clientX - pointerDownPos.x) > 5 || Math.abs(e.clientY - pointerDownPos.y) > 5) {
                isDragging = true;
            }
        });

        window.addEventListener('pointerup', (e) => {
            if (gameState !== 'playing' || e.target.tagName !== 'CANVAS' || isDragging) return;

            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Alvos: Peças construídas + Chão
            const targets = blocks.map(b => b.mesh).concat(groundPlane);
            const intersects = raycaster.intersectObjects(targets);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                buildBlock(intersect);
            }
        });

        function buildBlock(intersect) {
            const matDef = MATERIALS[currentTool];
            if (config.budget < matDef.cost) return;

            const normal = intersect.face.normal;
            
            // Posição baseada no ponto clicado + avanço no eixo da normal
            let pX = intersect.point.x + normal.x * (matDef.w / 2);
            let pY = intersect.point.y + normal.y * (matDef.h / 2);
            let pZ = intersect.point.z + normal.z * (matDef.d / 2);

            // Snap ao grid nos eixos X e Z para manter alinhamento
            pX = Math.round(pX / GRID_SNAP) * GRID_SNAP;
            pZ = Math.round(pZ / GRID_SNAP) * GRID_SNAP;

            // Tratamento especial para o eixo Y (Altura) para encaixe perfeito
            if (intersect.object === groundPlane) {
                pY = matDef.h / 2;
            } else if (normal.y > 0.5) { // Clicou no topo de um bloco
                pY = intersect.object.position.y + (intersect.object.geometry.parameters.height / 2) + (matDef.h / 2);
            }

            // Criação do Mesh
            const geo = new THREE.BoxGeometry(matDef.w, matDef.h, matDef.d);
            const mat = new THREE.MeshStandardMaterial({ color: matDef.color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(pX, pY, pZ);
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            scene.add(mesh);

            // Objeto lógico de negócio
            const newBlock = {
                type: currentTool,
                w: matDef.w, h: matDef.h, d: matDef.d,
                vol: matDef.w * matDef.h * matDef.d,
                mesh: mesh,
                tension: 0,
                baseColor: new THREE.Color(matDef.color)
            };

            blocks.push(newBlock);
            config.budget -= matDef.cost;
            updateHUD();

            if (config.budget < 0) endGame('Seu orçamento estourou!');
        }

        /**
         * ==========================================
         * 4. FÍSICA E REGRAS DE NEGÓCIO
         * ==========================================
         */
        function calculatePhysics() {
            // Reseta tensões
            blocks.forEach(b => b.tension = 0);

            // Ordena de cima para baixo (eixo Y)
            let sorted = [...blocks].sort((a,b) => b.mesh.position.y - a.mesh.position.y);

            sorted.forEach(topBlock => {
                let weight = topBlock.vol * MATERIALS[topBlock.type].density * 9.8;
                topBlock.tension += weight;

                blocks.forEach(botBlock => {
                    if (topBlock === botBlock) return;
                    
                    // Verifica se botBlock está imediatamente abaixo e tocando topBlock
                    const tY = topBlock.mesh.position.y;
                    const bY = botBlock.mesh.position.y;
                    const tH = topBlock.h;
                    const bH = botBlock.h;

                    if (Math.abs((tY - tH/2) - (bY + bH/2)) < 0.1) {
                        // Verifica AABB em X e Z para ver se há sobreposição
                        const tx = topBlock.mesh.position.x;
                        const tz = topBlock.mesh.position.z;
                        const bx = botBlock.mesh.position.x;
                        const bz = botBlock.mesh.position.z;

                        if (Math.abs(tx - bx) < (topBlock.w + botBlock.w)/2 - 0.01 &&
                            Math.abs(tz - bz) < (topBlock.d + botBlock.d)/2 - 0.01) {
                            botBlock.tension += topBlock.tension;
                        }
                    }
                });
            });

            // Aplica cor de stress e verifica colapso
            const dangerColor = new THREE.Color(0xe74c3c);

            for (let b of blocks) {
                let area = b.w * b.d;
                let pressure = b.tension / area;
                let stressRatio = pressure / MATERIALS[b.type].limit;

                // Interpola a cor natural com a cor de perigo
                b.mesh.material.color.lerpColors(b.baseColor, dangerColor, Math.min(stressRatio, 1));

                if (stressRatio > 1.0) {
                    endGame('A estrutura colapsou devido ao excesso de carga!');
                    return;
                }
            }
        }

        function checkWinCondition() {
            if (blocks.length === 0) return;

            // 1. Calcula Altura Máxima (Topo do bloco mais alto)
            let maxH = blocks.reduce((max, b) => Math.max(max, b.mesh.position.y + b.h/2), 0);
            
            // 2. Calcula Área da Base (Footprint)
            // Consideramos peças "na base" aquelas cujo fundo toca o chão (Y - H/2 <= 0.1)
            let baseArea = blocks
                .filter(b => (b.mesh.position.y - b.h/2) <= 0.1)
                .reduce((sum, b) => sum + (b.w * b.d), 0);

            document.getElementById('txt-alt').innerText = maxH.toFixed(1);
            document.getElementById('txt-area').innerText = baseArea.toFixed(1);
            
            if (maxH >= config.targetAlt && baseArea >= config.targetArea) {
                endGame('Objetivos de Altura e Área alcançados!', true);
            }
        }

        /**
         * ==========================================
         * 5. LÓGICA DE INTERFACE E ESTADO
         * ==========================================
         */
        function startGame(difficulty) {
            document.getElementById('screen-start').style.display = 'none';
            gameState = 'playing';
            
            if(difficulty === 'easy') config = { budget: 50000, targetAlt: 10, targetArea: 4, mult: 1 };
            if(difficulty === 'medium') config = { budget: 30000, targetAlt: 20, targetArea: 10, mult: 2 };
            if(difficulty === 'hard') config = { budget: 15000, targetAlt: 40, targetArea: 20, mult: 3 };

            document.getElementById('target-alt').innerText = config.targetAlt;
            document.getElementById('target-area').innerText = config.targetArea;
            
            updateHUD();
            startTimer();
            animate();
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.btn-tool').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
        }

        function updateHUD() {
            document.getElementById('txt-budget').innerText = config.budget;
        }

        function startTimer() {
            const timerEl = document.getElementById('timer');
            const interval = setInterval(() => {
                if (gameState !== 'playing') { clearInterval(interval); return; }
                
                timeLeft--;
                let min = Math.floor(timeLeft / 60);
                let sec = timeLeft % 60;
                timerEl.innerText = `${min.toString().padStart(2,'0')}:${sec.toString().padStart(2,'0')}`;

                if (timeLeft <= 60) timerEl.classList.add('critical-time');
                if (timeLeft <= 0) endGame('O tempo acabou!');
            }, 1000);
        }

        function endGame(msg, win = false) {
            gameState = 'end';
            document.getElementById('screen-gameover').style.display = 'flex';
            document.getElementById('end-title').innerText = win ? "MISSÃO CUMPRIDA!" : "FALHA ESTRUTURAL";
            document.getElementById('end-title').style.color = win ? "var(--success)" : "var(--danger)";
            document.getElementById('end-msg').innerText = msg;

            if (win) {
                let score = Math.floor((config.budget + (timeLeft * 10)) * config.mult);
                document.getElementById('final-score').innerText = score;
                document.getElementById('win-section').style.display = 'block';
            }
            showRanking();
        }

        function saveScore() {
            const name = document.getElementById('player-name').value.toUpperCase() || 'ANO';
            const score = parseInt(document.getElementById('final-score').innerText);
            let ranking = JSON.parse(localStorage.getItem('isometric_rank') || '[]');
            
            ranking.push({ name, score });
            ranking.sort((a, b) => b.score - a.score);
            ranking = ranking.slice(0, 5);
            
            localStorage.setItem('isometric_rank', JSON.stringify(ranking));
            document.getElementById('win-section').style.display = 'none';
            showRanking();
        }

        function showRanking() {
            let ranking = JSON.parse(localStorage.getItem('isometric_rank') || '[]');
            let html = '<table class="ranking-table"><tr><th>POS</th><th>ENG</th><th>PTS</th></tr>';
            ranking.forEach((r, i) => {
                html += `<tr><td>${i+1}º</td><td>${r.name}</td><td>${r.score}</td></tr>`;
            });
            html += '</table>';
            document.getElementById('ranking-container').innerHTML = html;
        }

        /**
         * ==========================================
         * 6. LOOP DE RENDERIZAÇÃO
         * ==========================================
         */
        function animate() {
            if (gameState !== 'playing') return;
            requestAnimationFrame(animate);

            controls.update(); // Necessário por conta do enableDamping
            
            if (blocks.length > 0) {
                calculatePhysics();
                checkWinCondition();
            }

            renderer.render(scene, camera);
        }

        // Renderização estática inicial para a tela de Start
        renderer.render(scene, camera);

    </script>
</body>
</html>
